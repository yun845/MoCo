<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>DeviceMotion 滾球視覺化</title>
<style>
  body { 
    margin: 0; 
    padding: 0; 
    overflow: hidden; /* 防止捲動 */
    background-color: #222; 
    font-family: sans-serif;
    touch-action: none; /* 停用觸控縮放 */
  }
  
  #info {
    position: absolute;
    top: 20px;
    left: 20px;
    color: white;
    z-index: 10;
    pointer-events: none; /* 讓點擊穿透文字 */
  }

  #startBtn {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 15px 30px;
    font-size: 18px;
    background: #007bff;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    z-index: 20;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
  }
</style>
</head>
<body>

<div id="info">
  <h2>滾球測試</h2>
  <p>請水平握持手機並傾斜</p>
  <div id="debug">等待啟動...</div>
</div>

<button id="startBtn">點擊啟用感測器</button>
<canvas id="gameCanvas"></canvas>

<script>
// --- 變數設定 ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const debug = document.getElementById('debug');
const startBtn = document.getElementById('startBtn');

// 球的物理屬性
let ball = {
  x: 0,
  y: 0,
  radius: 20,
  vx: 0, // X軸速度
  vy: 0, // Y軸速度
  color: '#ffdd00'
};

// 感測器數值
let accX = 0;
let accY = 0;

// 物理參數
const FRICTION = 0.98; // 摩擦力 (0.98 代表每幀速度衰減 2%)
const SENSITIVITY = 0.5; // 感測器靈敏度

// --- 初始化 Canvas ---
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  // 重置球的位置到中心
  if (ball.x === 0 && ball.y === 0) {
    ball.x = canvas.width / 2;
    ball.y = canvas.height / 2;
  }
}
window.addEventListener('resize', resize);
resize();

// --- 權限處理 (iOS 必備) ---
async function requestPermission() {
  if (typeof DeviceMotionEvent.requestPermission === 'function') {
    try {
      const state = await DeviceMotionEvent.requestPermission();
      if (state === 'granted') return true;
      alert("權限被拒絕");
      return false;
    } catch (e) {
      console.error(e);
      return false;
    }
  }
  return true; // 非 iOS 或舊版不需要權限
}

// --- 主要邏輯 ---
startBtn.addEventListener('click', async () => {
  const allowed = await requestPermission();
  
  if (allowed) {
    startBtn.style.display = 'none'; // 隱藏按鈕
    
    // 監聽感測器
    window.addEventListener('devicemotion', (event) => {
      // 取得含重力的加速度
      // 注意：不同裝置方向定義可能略有不同，這裡針對手機直拿或平放優化
      // Android/iOS 的座標系有時相反，這裡做一個通用的對應
      const acc = event.accelerationIncludingGravity;
      
      if (acc) {
        // x 軸通常對應手機左右傾斜
        // y 軸通常對應手機前後傾斜
        // 我們將數值反向或調整以符合視覺直覺
        accX = acc.x || 0; 
        accY = acc.y || 0; 
        
        // 更新除錯文字
        debug.textContent = `X: ${accX.toFixed(1)}, Y: ${accY.toFixed(1)}`;
      }
    });

    // 啟動動畫迴圈
    animate();
  }
});

// --- 動畫迴圈 (每秒約 60 次) ---
function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height); // 清空畫面

  // 1. 根據感測器更新速度
  // 注意：這裡的 -accX 是因為手機向左傾斜 X 為負，但我們希望球往左(X減小)跑，或往右跑?
  // 視手機拿法而定，如果不順手可以把加號改減號
  ball.vx += accX * SENSITIVITY; 
  ball.vy -= accY * SENSITIVITY; // Y軸通常螢幕向下是正，感測器向上傾斜Y變負

  // 2. 套用摩擦力 (讓球會慢慢停下來)
  ball.vx *= FRICTION;
  ball.vy *= FRICTION;

  // 3. 更新位置
  ball.x += ball.vx;
  ball.y += ball.vy;

  // 4. 邊界檢查 (碰到牆壁反彈)
  // 左邊界
  if (ball.x - ball.radius < 0) {
    ball.x = ball.radius;
    ball.vx *= -0.7; // 撞牆反彈並損失能量
  }
  // 右邊界
  if (ball.x + ball.radius > canvas.width) {
    ball.x = canvas.width - ball.radius;
    ball.vx *= -0.7;
  }
  // 上邊界
  if (ball.y - ball.radius < 0) {
    ball.y = ball.radius;
    ball.vy *= -0.7;
  }
  // 下邊界
  if (ball.y + ball.radius > canvas.height) {
    ball.y = canvas.height - ball.radius;
    ball.vy *= -0.7;
  }

  // 5. 繪製球
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
  ctx.fillStyle = ball.color;
  ctx.fill();
  
  // 增加一點光澤感
  ctx.beginPath();
  ctx.arc(ball.x - 5, ball.y - 5, ball.radius / 3, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
  ctx.fill();

  requestAnimationFrame(animate);
}
</script>

</body>
</html>
